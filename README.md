> [!WARNING]  
> This is a POC for an Anchor SDK generated by Robots ðŸ¤–. Not for use in a production setting. 
> 
# Anchor SDK Go â€” v1 Implementation Guide

This document describes the **actual v1 implementation** of the Stellar Connect SDK for Go. For the ideal design and future roadmap, see [rfc.md](./rfc.md).

## Installation

```bash
go get github.com/marwen-abid/anchor-sdk-go
```

**Module path**: `github.com/marwen-abid/anchor-sdk-go`

## Package Structure

```
github.com/marwen-abid/anchor-sdk-go/
â”œâ”€â”€ stellarconnect.go       # Root interfaces: Signer, TransferStore, NonceStore, JWTIssuer/Verifier
â”œâ”€â”€ anchor/
â”‚   â”œâ”€â”€ auth.go             # AuthIssuer: SEP-10 challenge/verify, RequireAuth middleware
â”‚   â”œâ”€â”€ transfer.go         # TransferManager: deposit/withdrawal lifecycle
â”‚   â”œâ”€â”€ hooks.go            # HookRegistry: event callbacks
â”‚   â”œâ”€â”€ fsm.go              # Transfer state machine validation
â”‚   â””â”€â”€ jwt.go              # HMAC JWT issuer/verifier helper
â”œâ”€â”€ sdk/
â”‚   â”œâ”€â”€ client.go           # Client: anchor discovery
â”‚   â”œâ”€â”€ auth.go             # Session, Login (SEP-10), Deposit/Withdraw (SEP-24)
â”‚   â””â”€â”€ transfer.go         # TransferProcess: polling, status callbacks
â”œâ”€â”€ observer/
â”‚   â”œâ”€â”€ observer.go         # Observer interface, PaymentEvent, filters
â”‚   â”œâ”€â”€ horizon.go          # HorizonObserver: streams payments from Horizon
â”‚   â””â”€â”€ match.go            # AutoMatchPayments: links payments to withdrawals
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ toml/
â”‚   â”‚   â”œâ”€â”€ types.go        # AnchorInfo, CurrencyInfo
â”‚   â”‚   â”œâ”€â”€ publisher.go    # TOML publisher (stellar.toml handler)
â”‚   â”‚   â””â”€â”€ resolver.go     # TOML resolver (fetches/parses stellar.toml)
â”‚   â”œâ”€â”€ net/
â”‚   â”‚   â””â”€â”€ client.go       # HTTP client wrapper
â”‚   â”œâ”€â”€ crypto/
â”‚   â”‚   â””â”€â”€ crypto.go       # Nonce generation
â”‚   â””â”€â”€ account/
â”‚       â””â”€â”€ doc.go          # (Account inspector not implemented in v1)
â”œâ”€â”€ signers/
â”‚   â”œâ”€â”€ keypair.go          # FromSecret: creates Signer from secret key
â”‚   â””â”€â”€ callback.go         # Callback signer for custom signing
â”œâ”€â”€ store/
â”‚   â””â”€â”€ memory/
â”‚       â”œâ”€â”€ transfer.go     # In-memory TransferStore
â”‚       â””â”€â”€ nonce.go        # In-memory NonceStore
â””â”€â”€ errors/
    â””â”€â”€ errors.go           # Typed SDK errors
```

## Core Interfaces

All core interfaces are defined in `stellarconnect.go`.

### Signer

```go
type Signer interface {
    PublicKey() string
    SignTransaction(ctx context.Context, xdr string) (string, error)
}
```

Create a signer from a secret key:

```go
import "github.com/marwen-abid/anchor-sdk-go/signers"

signer, err := signers.FromSecret("SABC...")
```

### TransferStore

```go
type TransferStore interface {
    Save(ctx context.Context, transfer *Transfer) error
    FindByID(ctx context.Context, id string) (*Transfer, error)
    FindByAccount(ctx context.Context, account string) ([]*Transfer, error)
    Update(ctx context.Context, id string, update *TransferUpdate) error
    List(ctx context.Context, filters TransferFilters) ([]*Transfer, error)
}
```

In-memory implementation provided:

```go
import "github.com/marwen-abid/anchor-sdk-go/store/memory"

store := memory.NewTransferStore()
```

### NonceStore

```go
type NonceStore interface {
    Add(ctx context.Context, nonce string, expiresAt time.Time) error
    Consume(ctx context.Context, nonce string) (bool, error)
}
```

In-memory implementation:

```go
nonceStore := memory.NewNonceStore()
```

### JWTIssuer / JWTVerifier

```go
type JWTIssuer interface {
    Issue(ctx context.Context, claims JWTClaims) (string, error)
}

type JWTVerifier interface {
    Verify(ctx context.Context, token string) (*JWTClaims, error)
}
```

HMAC JWT helper:

```go
import "github.com/marwen-abid/anchor-sdk-go/anchor"

jwtIssuer, jwtVerifier := anchor.NewHMACJWT(
    []byte("your-secret-key"),
    "anchor.example.com",
    24*time.Hour,
)
```

---

## Anchor Server Components

The SDK provides **individual components** that you wire together. There is no `anchor.Server` orchestrator in v1.

### AuthIssuer (SEP-10)

Handles SEP-10 Web Authentication:

```go
import "github.com/marwen-abid/anchor-sdk-go/anchor"

authIssuer, err := anchor.NewAuthIssuer(anchor.AuthConfig{
    Domain:            "localhost:8000",
    NetworkPassphrase: "Test SDF Network ; September 2015",
    Signer:            signer,
    NonceStore:        nonceStore,
    JWTIssuer:         jwtIssuer,
    JWTVerifier:       jwtVerifier,
})
```

**Methods:**

| Method | Description |
|--------|-------------|
| `CreateChallenge(ctx, account string) (string, error)` | Creates SEP-10 challenge XDR |
| `VerifyChallenge(ctx, signedXDR string) (string, error)` | Verifies signed challenge, returns JWT |
| `RequireAuth(http.Handler) http.Handler` | Middleware that validates Bearer tokens |
| `ClaimsFromContext(ctx) (*JWTClaims, bool)` | Extracts claims from request context |

**HTTP Handler Example:**

```go
// GET /auth - return challenge
mux.HandleFunc("GET /auth", func(w http.ResponseWriter, r *http.Request) {
    account := r.URL.Query().Get("account")
    challengeXDR, err := authIssuer.CreateChallenge(r.Context(), account)
    // ... return JSON { transaction, network_passphrase }
})

// POST /auth - verify and return JWT
mux.HandleFunc("POST /auth", func(w http.ResponseWriter, r *http.Request) {
    var req struct { Transaction string `json:"transaction"` }
    json.NewDecoder(r.Body).Decode(&req)
    token, err := authIssuer.VerifyChallenge(r.Context(), req.Transaction)
    // ... return JSON { token }
})

// Protected endpoint
mux.Handle("GET /sep24/transactions", authIssuer.RequireAuth(
    http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        claims, _ := anchor.ClaimsFromContext(r.Context())
        // claims.Subject contains the authenticated Stellar account
    }),
))
```

### TransferManager (SEP-6/SEP-24)

Manages deposit and withdrawal lifecycle:

```go
transferManager := anchor.NewTransferManager(
    transferStore,
    anchor.Config{
        Domain:             "localhost:8000",
        InteractiveBaseURL: "http://localhost:8000/interactive",
    },
    hookRegistry, // optional, nil creates empty registry
)
```

**Methods:**

| Method | Description |
|--------|-------------|
| `InitiateDeposit(ctx, DepositRequest) (*DepositResult, error)` | Start a deposit |
| `InitiateWithdrawal(ctx, WithdrawalRequest) (*WithdrawalResult, error)` | Start a withdrawal |
| `CompleteInteractive(ctx, transferID, data) error` | Mark interactive KYC complete |
| `VerifyInteractiveToken(ctx, token) (*Transfer, error)` | Validate interactive URL token |
| `NotifyFundsReceived(ctx, id, FundsReceivedDetails) error` | Deposit: fiat received |
| `NotifyPaymentSent(ctx, id, PaymentSentDetails) error` | Deposit: Stellar payment sent |
| `NotifyPaymentReceived(ctx, id, PaymentReceivedDetails) error` | Withdrawal: Stellar payment received |
| `NotifyDisbursementSent(ctx, id, DisbursementDetails) error` | Withdrawal: fiat disbursed |
| `GetStatus(ctx, id) (*TransferStatusResponse, error)` | Get transfer status |
| `Deny(ctx, id, reason) error` | Deny a transfer |
| `Cancel(ctx, id, reason) error` | Cancel a transfer |

**Request/Response Types:**

```go
type DepositRequest struct {
    Account   string
    AssetCode string
    Amount    string
    Mode      stellarconnect.TransferMode // ModeInteractive or ModeAPI
    Metadata  map[string]any
}

type DepositResult struct {
    ID             string
    InteractiveURL string // For ModeInteractive
    Instructions   string // For ModeAPI
    ETA            int
}

type WithdrawalRequest struct {
    Account   string
    AssetCode string
    Amount    string
    Mode      stellarconnect.TransferMode
    Dest      string
    DestExtra string
    Metadata  map[string]any
}

type WithdrawalResult struct {
    ID              string
    InteractiveURL  string
    StellarAccount  string // Where to send Stellar payment
    StellarMemo     string
    StellarMemoType string
    ETA             int
}
```

### HookRegistry

Register callbacks for transfer lifecycle events:

```go
hooks := anchor.NewHookRegistry()

hooks.On(anchor.HookDepositInitiated, func(t *stellarconnect.Transfer) {
    log.Printf("Deposit %s initiated for %s", t.ID, t.Account)
})

hooks.On(anchor.HookWithdrawalStellarPaymentSent, func(t *stellarconnect.Transfer) {
    log.Printf("Withdrawal %s: payment received, tx=%s", t.ID, t.StellarTxHash)
})

hooks.On(anchor.HookTransferStatusChanged, func(t *stellarconnect.Transfer) {
    log.Printf("Transfer %s status: %s", t.ID, t.Status)
})
```

**Available Hooks:**

| Hook | When Triggered |
|------|----------------|
| `HookDepositInitiated` | Deposit created |
| `HookDepositFundsReceived` | Fiat funds received for deposit |
| `HookWithdrawalInitiated` | Withdrawal created |
| `HookWithdrawalStellarPaymentSent` | Stellar payment received for withdrawal |
| `HookTransferStatusChanged` | Any status transition |

**Note:** Hook handlers have signature `func(*Transfer)` (no context or data map).

### TOML Publisher (SEP-1)

Serves `stellar.toml`:

```go
import "github.com/marwen-abid/anchor-sdk-go/core/toml"

anchorInfo := &toml.AnchorInfo{
    NetworkPassphrase:   "Test SDF Network ; September 2015",
    SigningKey:          signer.PublicKey(),
    WebAuthEndpoint:     "http://localhost:8000/auth",
    TransferServerSep6:  "http://localhost:8000/sep6",
    TransferServerSep24: "http://localhost:8000/sep24",
    Currencies: []toml.CurrencyInfo{
        {
            Code:            "USDC",
            Issuer:          "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5",
            Status:          "test",
            DisplayDecimals: 2,
            AnchorAssetType: "fiat",
            Description:     "Test USDC",
        },
    },
}

publisher := toml.NewPublisher(anchorInfo)
mux.HandleFunc("/.well-known/stellar.toml", publisher.Handler())
```

**AnchorInfo Fields (v1):**

| Field | TOML Key |
|-------|----------|
| `NetworkPassphrase` | `NETWORK_PASSPHRASE` |
| `SigningKey` | `SIGNING_KEY` |
| `WebAuthEndpoint` | `WEB_AUTH_ENDPOINT` |
| `TransferServerSep6` | `TRANSFER_SERVER` |
| `TransferServerSep24` | `TRANSFER_SERVER_SEP0024` |
| `Currencies` | `[[CURRENCIES]]` |

---

## Observer (Payment Watching)

The Observer streams Stellar payments for automatic withdrawal matching.

### HorizonObserver

```go
import "github.com/marwen-abid/anchor-sdk-go/observer"

obs := observer.NewHorizonObserver(
    "https://horizon-testnet.stellar.org",
    observer.WithCursor("now"),
    observer.WithCursorSaver(func(cursor string) error {
        // Persist cursor for resumability
        return db.SaveCursor(cursor)
    }),
)

// Register payment handler with filters
obs.OnPayment(func(evt observer.PaymentEvent) error {
    log.Printf("Payment: %s -> %s, %s %s",
        evt.From, evt.To, evt.Amount, evt.Asset)
    return nil
}, observer.WithAsset("USDC:GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"))

// Start in goroutine (blocks until stopped)
go obs.Start(ctx)

// Stop gracefully
obs.Stop()
```

### PaymentEvent

```go
type PaymentEvent struct {
    ID              string // Operation ID
    From            string // Source account
    To              string // Destination account
    Asset           string // "native" or "CODE:ISSUER"
    Amount          string // e.g., "100.0000000"
    Memo            string // Transaction memo
    Cursor          string // Paging token for resumability
    TransactionHash string // Transaction hash
}
```

### Filters

| Filter | Description |
|--------|-------------|
| `WithAsset(code string)` | Match specific asset (e.g., "USDC:G...") |
| `WithMinAmount(min string)` | Match payments >= amount |
| `WithAccount(id string)` | Match payments to OR from account |
| `WithDestination(id string)` | Match payments TO account |
| `WithSource(id string)` | Match payments FROM account |

Filters are ANDed together.

### AutoMatchPayments

Automatically links incoming Stellar payments to pending withdrawals:

```go
err := observer.AutoMatchPayments(obs, transferManager, distributionAccount)
```

This registers a payment handler that:
1. Filters for payments TO `distributionAccount`
2. Looks up transfers by memo (transfer ID)
3. Calls `transferManager.NotifyPaymentReceived()` to advance the withdrawal

---

## Client SDK

For wallet/application integration with anchors.

### Client

```go
import "github.com/marwen-abid/anchor-sdk-go/sdk"

client := sdk.NewClient("Test SDF Network ; September 2015")
```

Options:
- `sdk.WithHTTPClient(*net.Client)` - Custom HTTP client

### Login (SEP-10)

```go
session, err := client.Login(ctx, accountAddress, "anchor.example.com", signer)
if err != nil {
    // Handle error
}

// session.JWT contains the auth token
// session.ExpiresAt is when it expires
```

**Note:** v1 only supports SEP-10 (transaction signing). SEP-45 (message signing) is not implemented.

### Session

```go
type Session struct {
    HomeDomain string    // Anchor domain
    Account    string    // Authenticated Stellar account
    JWT        string    // Bearer token
    ExpiresAt  time.Time // Token expiration
}

session.IsValid() // Returns true if not expired
```

**Note:** v1 does not have `Session.Refresh()` or `Capabilities`.

### Deposit / Withdraw (SEP-24)

```go
// Initiate deposit
process, err := session.Deposit(ctx, "USDC", "100")
if err != nil {
    // Handle error
}

// Get interactive URL for KYC
fmt.Println("Open:", process.InteractiveURL)

// Register callbacks
process.OnStatusChange(func(status stellarconnect.TransferStatus) {
    fmt.Println("Status:", status)
})

process.OnInteractive(func(url string) {
    fmt.Println("Open browser:", url)
})

// Poll for updates
err = process.Poll(ctx)

// Or wait for completion (blocking with adaptive backoff)
err = process.WaitForCompletion(ctx)
```

### TransferProcess

```go
type TransferProcess struct {
    ID             string
    Status         stellarconnect.TransferStatus
    InteractiveURL string
}
```

**Methods:**

| Method | Description |
|--------|-------------|
| `OnStatusChange(func(TransferStatus))` | Callback when status changes |
| `OnInteractive(func(string))` | Callback when interactive URL available |
| `Poll(ctx) error` | Fetch current status from anchor |
| `WaitForCompletion(ctx) error` | Block until terminal status |

**Note:** v1 only supports SEP-24 interactive flows. SEP-6 API mode is not implemented on the client side.

---

## Transfer States

The SDK uses a state machine for transfers. Status is managed by the SDK, never set directly.

```
initiating â†’ interactive â†’ pending_user_transfer_start â†’ pending_external â†’ pending_stellar â†’ completed
                                                      â†˜                                    â†—
                                                        â†’ payment_required â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Any state can transition to: failed, denied, cancelled, expired
```

| Status | Description |
|--------|-------------|
| `initiating` | Transfer just created |
| `interactive` | User must complete KYC/form |
| `pending_user_transfer_start` | Waiting for user to send funds |
| `pending_external` | Processing off-chain (bank transfer) |
| `pending_stellar` | Processing on-chain transaction |
| `payment_required` | User must send Stellar payment |
| `completed` | Transfer complete |
| `failed` | Unrecoverable error |
| `denied` | Rejected by compliance |
| `cancelled` | Cancelled by user/system |
| `expired` | Timed out |

---

## Complete Example

See [`examples/anchor/main.go`](examples/basic-anchor/main.go) for a full working anchor server.

```go
package main

import (
    "context"
    "fmt"
    "log"
    "net/http"

    "github.com/marwen-abid/anchor-sdk-go/anchor"
    "github.com/marwen-abid/anchor-sdk-go/core/toml"
    "github.com/marwen-abid/anchor-sdk-go/observer"
    "github.com/marwen-abid/anchor-sdk-go/signers"
    "github.com/marwen-abid/anchor-sdk-go/store/memory"
)

func main() {
    // 1. Create signer
    signer, _ := signers.FromSecret("SABC...")

    // 2. Create stores
    nonceStore := memory.NewNonceStore()
    transferStore := memory.NewTransferStore()

    // 3. Create JWT issuer/verifier
    jwtIssuer, jwtVerifier := anchor.NewHMACJWT(
        []byte("secret"),
        "localhost:8000",
        24*time.Hour,
    )

    // 4. Create AuthIssuer (SEP-10)
    authIssuer, _ := anchor.NewAuthIssuer(anchor.AuthConfig{
        Domain:            "localhost:8000",
        NetworkPassphrase: "Test SDF Network ; September 2015",
        Signer:            signer,
        NonceStore:        nonceStore,
        JWTIssuer:         jwtIssuer,
        JWTVerifier:       jwtVerifier,
    })

    // 5. Create TransferManager (SEP-6/SEP-24)
    transferManager := anchor.NewTransferManager(
        transferStore,
        anchor.Config{
            Domain:             "localhost:8000",
            InteractiveBaseURL: "http://localhost:8000/interactive",
        },
        nil,
    )

    // 6. Create Observer
    obs := observer.NewHorizonObserver(
        "https://horizon-testnet.stellar.org",
        observer.WithCursor("now"),
    )
    observer.AutoMatchPayments(obs, transferManager, signer.PublicKey())
    go obs.Start(context.Background())

    // 7. Create TOML Publisher
    publisher := toml.NewPublisher(&toml.AnchorInfo{
        NetworkPassphrase:   "Test SDF Network ; September 2015",
        SigningKey:          signer.PublicKey(),
        WebAuthEndpoint:     "http://localhost:8000/auth",
        TransferServerSep6:  "http://localhost:8000/sep6",
        TransferServerSep24: "http://localhost:8000/sep24",
        Currencies: []toml.CurrencyInfo{
            {Code: "USDC", Issuer: "GBBD47IF6LWK7P7MDEVSCWR7DPUWV3NY3DTQEVFL4NAT4AQH3ZLLFLA5"},
        },
    })

    // 8. Wire HTTP routes
    mux := http.NewServeMux()
    mux.HandleFunc("/.well-known/stellar.toml", publisher.Handler())
    mux.HandleFunc("GET /auth", handleGetChallenge(authIssuer))
    mux.HandleFunc("POST /auth", handlePostChallenge(authIssuer))
    mux.Handle("POST /sep24/transactions/deposit/interactive",
        authIssuer.RequireAuth(http.HandlerFunc(handleDeposit(transferManager))))
    // ... more routes

    log.Fatal(http.ListenAndServe(":8000", mux))
}
```

---

## v1 Limitations

The following are **not implemented in v1** (see RFC for future plans):

| Feature | RFC Section | v1 Status |
|---------|-------------|-----------|
| `anchor.Server` orchestrator | Â§6.2 | Not implemented â€” use components directly |
| Account Inspector | Â§5.4 | Not implemented |
| SEP-45 (message signing) | Â§4.1, Â§7.2 | Not implemented â€” SEP-10 only |
| SEP-6 client API mode | Â§7.3 | Not implemented â€” SEP-24 interactive only |
| Session refresh | Â§7.2 | Not implemented |
| Postgres store | Â§10 | Not implemented â€” in-memory only |
| Path payment handling | Â§4.5 | Skipped in observer |

---

## Dependencies

The SDK only depends on:
- `github.com/stellar/go-stellar-sdk` (official Stellar SDK)
- Go standard library

No web frameworks, ORMs, or database drivers.

---

## Error Handling

All SDK errors are typed:

```go
import "github.com/marwen-abid/anchor-sdk-go/errors"

if err != nil {
    if sdkErr, ok := errors.As[*errors.AnchorError](err); ok {
        switch sdkErr.Code {
        case errors.CHALLENGE_VERIFY_FAILED:
            // Handle auth failure
        case errors.STORE_ERROR:
            // Handle persistence failure
        }
    }
}
```

See `errors/errors.go` for all error codes.
